<!doctype html><html><head><title>Deep Reinforcement Learning at the Edge of the Statistical Precipice</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="ie=edge"><link rel=stylesheet href=/assets/css/bootstrap.min.css><link rel=stylesheet href=/assets/css/layouts/main.css><link rel=stylesheet href=/assets/css/style.css><link rel=stylesheet href=/assets/css/navigators/navbar.css><link href="https://fonts.googleapis.com/css2?family=Muli:wght@300;400;500;600" rel=stylesheet><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.min.css><link rel=icon type=image/png href=/assets/images/psc_emoji.png><link rel=stylesheet href=/assets/css/style.css><script>MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']],processEscapes:true,processEnvironments:true},options:{skipHtmlTags:['script','noscript','style','textarea','pre']}};window.addEventListener('load',(event)=>{document.querySelectorAll("mjx-container").forEach(function(x){x.parentElement.classList+='has-jax'})});</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><meta name=description content="Deep Reinforcement Learning at the Edge of the Statistical Precipice"><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/atom-one-dark.min.css><link rel=stylesheet href=/assets/css/layouts/single.css><link rel=stylesheet href=/assets/css/navigators/sidebar.css><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-XXXXXXXXX-X','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script></head><body data-spy=scroll data-target=#TableOfContents data-offset=80><div class="container-fluid bg-dimmed wrapper"><nav class="navbar navbar-expand-xl top-navbar final-navbar shadow"><div class=container><button class="navbar-toggler navbar-light" id=sidebar-toggler type=button onclick=toggleSidebar()>
<span class=navbar-toggler-icon></span></button>
<a class=navbar-brand href=/><img src=/assets/images/psc_emoji.png>psc's website</a>
<button class="navbar-toggler navbar-light" id=toc-toggler type=button onclick=toggleTOC()>
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse lang-selector" id=top-nav-items><ul class="navbar-nav ml-auto"></ul></div></div><img src=/assets/images/psc_emoji.png class=d-none id=main-logo>
<img src=/assets/images/psc_emoji.png class=d-none id=inverted-logo></nav><section class=sidebar-section id=sidebar-section><div class=sidebar-holder><div class=sidebar id=sidebar><input type=text placeholder=Search data-search id=search-box><div class=sidebar-tree><ul class=tree id=tree><li id=list-heading><a href=/posts data-filter=all>Posts</a></li><div class=subtree><li><i class="fas fa-plus-circle"></i><a href=/posts/mentoring/>Mentoring / Education</a><ul><li><a href=/posts/mentoring/cme/>CME is A-OK</a></li><li><a href=/posts/mentoring/gridworldplayground/>GridWorld Playground</a></li><li><a href=/posts/mentoring/introduccion-a-transformers/>Intro a Transformers</a></li><li><a href=/posts/mentoring/intro-to-rl/>Intro to RL</a></li><li><a href=/posts/mentoring/resume/>Preparing your resume</a></li><li><a href=/posts/mentoring/interviewing/>Tips for Interviewing at Google</a></li><li><a href=/posts/mentoring/reviewing/>Tips for Reviewing Research Papers</a></li></ul></li><li><i class="fas fa-plus-circle"></i><a href=/posts/musicode/>MUSICODE</a><ul><li><i class="fas fa-plus-circle"></i><a href=/posts/musicode/phase1/>Phase 1</a><ul><li><a href=/posts/musicode/phase1/introducing/>0-Introducing</a></li><li><a href=/posts/musicode/phase1/episode1/>1-Musical Note & Computation</a></li><li><a href=/posts/musicode/phase1/episode2/>2-Bits & Semitones</a></li><li><a href=/posts/musicode/phase1/episode3/>3-Leitmotifs & Variables</a></li><li><a href=/posts/musicode/phase1/episode4/>4-Live Coding & Jazz</a></li><li><a href=/posts/musicode/phase1/episode5/>5-Repeats & Loops</a></li></ul></li><li><a href=/posts/musicode/introducing/>Introducing</a></li><li><a href=/posts/musicode/ldd/>Losses, Dissonances, and Distortions</a></li><li><a href=/posts/musicode/hallelagine/>Portrait of Hallelagine</a></li></ul></li><li><i class="fas fa-plus-circle"></i><a href=/posts/art/>Art</a><ul><li><a href=/posts/art/cost-of-beauty/>Cost of Beauty</a></li><li><a href=/posts/art/covid-music/>Covid Music</a></li><li><a href=/posts/art/family/>Family</a></li><li><a href=/posts/art/jidiji/>JiDiJi</a></li><li><a href=/posts/art/musical-aquarium/>Musical Aquarium</a></li></ul></li><li><i class="fas fa-plus-circle"></i><a href=/posts/misc/>Misc</a><ul><li><a href=/posts/misc/agr/>Artificial General Relativity</a></li><li><a href=/posts/misc/crosswords/>Crosswords</a></li><li><a href=/posts/misc/origins/>Origins of April Fool's Day</a></li><li><a href=/posts/misc/yovoy/>yovoy</a></li></ul></li><li><i class="fas fa-minus-circle"></i><a class=active href=/posts/research/>Research</a><ul class=active><li><i class="fas fa-plus-circle"></i><a href=/posts/research/other/>Other</a><ul><li><a href=/posts/research/other/rigl/rigl/>RigL</a></li></ul></li><li><i class="fas fa-minus-circle"></i><a class=active href=/posts/research/rl/>RL</a><ul class=active><li><a href=/posts/research/rl/2020highlights/>2020 RL Highlights</a></li><li><a href=/posts/research/rl/pse/>Contrastive Behavioral Similarity Embeddings</a></li><li><a href=/posts/research/rl/dopamine/>Dopamine</a></li><li><a href=/posts/research/rl/loon/>Flying balloons with RL</a></li><li><a href=/posts/research/rl/metrics_continuity/>Metrics & continuity in RL</a></li><li><a href=/posts/research/rl/mico/>MICo</a></li><li><a href=/posts/research/rl/revisiting_rainbow/>Revisiting Rainbow</a></li><li><a href=/posts/research/rl/scalable/>Scalable methods ...</a></li><li><a href=/posts/research/rl/sparse_rl/>SparseRL</a></li><li><a class=active href=/posts/research/rl/precipice/>Statistical Precipice</a></li><li><a href=/posts/research/rl/tandem/>Tandem RL</a></li></ul></li><li><i class="fas fa-plus-circle"></i><a href=/posts/research/creativity/>Creativity</a><ul><li><a href=/posts/research/creativity/agence/>Agence, a dynamic film</a></li><li><a href=/posts/research/creativity/ganterpretations/>GANterpretations</a></li><li><a href=/posts/research/creativity/ml-jam/>ML-Jam</a></li></ul></li></ul></li></div></ul></div></div></div></section><section class=content-section id=content-section><div class=content><div class="container p-0 read-area"><div class="hero-area col-sm-12" id=hero-area style=background-image:url(https://psc-g.github.io/posts/research/rl/precipice/banner.png)></div><div class=page-content><div class="author-profile ml-auto align-self-lg-center"><img class=rounded-circle src=/assets/images/psc_gradient.png><h5 class=author-name>Pablo Samuel Castro</h5><p>December 6, 2021</p></div><div class=title><h1>Deep Reinforcement Learning at the Edge of the Statistical Precipice</h1></div><div class=post-content id=post-content><p>We argue that reliable evaluation in the few run deep RL regime cannot ignore
the uncertainty in results without running the risk of slowing down progress in
the field. We illustrate this point using a case study on the Atari 100k
benchmark, where we find substantial discrepancies between conclusions drawn
from point estimates alone versus a more thorough statistical analysis.
We advocate for reporting interval estimates of aggregate performance and
propose performance profiles to account for the variability in results, as well
as present more robust and efficient aggregate metrics, such as interquartile
mean scores, to achieve small uncertainty in results.</p><p><em>Rishabh Agarwal, Max Schwarzer, Pablo Samuel Castro, Aaron Courville, and Marc G. Bellemare</em></p><p>This blogpost is a summary of our
<a href=https://arxiv.org/abs/2108.13264>NeurIPS 2021 paper</a> (winner of an
<a href=https://blog.neurips.cc/2021/11/30/announcing-the-neurips-2021-award-recipients/>outstanding paper award</a>).
The code is available
<a href=https://github.com/google-research/rliable>here</a>.</p><h2 id=introduction>Introduction</h2><p>Research in artificial intelligence, and particularly deep reinforcement
learning (RL), relies on evaluating aggregate performance on a diverse suite of
tasks to assess progress. Quantitative evaluation on a suite of tasks, such as
Atari games, reveals strengths and limitations of methods while
simultaneously guiding researchers towards methods with promising results.
Performance of RL algorithms is usually summarized with a point estimate of
task performance measure, such as mean and median performance across tasks,
aggregated over independent training runs.</p><p>A small number of training runs coupled with high variability in
performance of deep RL algorithms, often leads to
substantial statistical uncertainty in reported point estimates. While
evaluating more runs per task has been prescribed to reduce uncertainty and
obtain reliable estimates, 3-10 runs are prevalent in deep RL as
it is often computationally prohibitive to evaluate more runs. For example, 5
runs each on 50+ Atari 2600 games in ALE using standard protocol requires more
than 1000 GPU training days. As we move towards more challenging and
complex RL benchmarks (e.g., StarCraft), evaluating more than a handful
of runs will become increasingly demanding due to increased amount of compute
and data needed to tackle such tasks. Additional confounding factors, such as
exploration in the low-data regime, exacerbates the performance variability in
deep RL – as seen on the Atari 100k benchmark – often requiring many more
runs to achieve negligible statistical uncertainty in reported estimates.</p><img src=/posts/research/rl/precipice/runsOverYears.png alt=runsOverYears width=75% class=center><p>Ignoring the statistical uncertainty in deep RL results gives a false
impression of fast scientific progress in the field. It inevitably evades the
question: &ldquo;Would similar findings be obtained with new independent runs under
different random conditions?&rdquo; This could steer researchers towards
superficially beneficial methods, often at the expense of better
methods being neglected or even rejected early as such methods fail to
outperform inferior methods simply due to less favorable random conditions.
Furthermore, reporting point estimates can erroneously lead the field to
conclude which methods are state-of-the-art, ensuing wasted effort and
sometimes degradation in performance over existing methods when applied in
practice. Moreover, not reporting the uncertainty in deep RL results
makes them difficult to reproduce except under the exact same random
conditions, which could lead to a reproducibility crisis similar to the one
that plagues other fields. Finally, unreliable results could erode
trust in deep RL research itself.</p><p>In this work, we show that recent deep RL papers compare unreliable point
estimates, which are dominated by statistical uncertainty, as well as exploit
non-standard evaluation protocols, using a case study on Atari 100k. Then, we
illustrate how to reliably evaluate performance with only a handful of runs
using a more rigorous evaluation methodology that accounts for uncertainty in
results. To exemplify the necessity of such methodology, we
scrutinize performance evaluations of existing algorithms on widely used
benchmarks, including the ALE (Atari 100k, Atari 200M), Procgen and
DeepMind Control Suite, again revealing discrepancies in prior
comparisons. Our findings call for a change in how we evaluate
performance in deep RL, for which we present a better methodology to prevent
unreliable results from stagnating the field.</p><p>How do we reliably evaluate performance on deep RL benchmarks with only a
handful of runs? As a practical solution that is easily applicable with 3-10
runs per task, we identify three statistical tools for improving the quality of
experimental reporting (see Table below). Since any performance estimate based
on a finite number of runs is a <em>random variable</em>, we argue that it should be
treated as such. Specifically, we argue for reporting aggregate performance
measures using <em>interval estimates</em> via stratified bootstrap confidence
intervals, as opposed to point estimates. Among prevalent aggregate measures,
mean can be easily dominated by performance on a few outlier tasks, while
median has high variability and zero performance on nearly half of the tasks
does not change it. To address these deficiencies, we present more <em>efficient</em>
and <em>robust</em> alternatives, such as <em>interquartile mean</em>, which are not unduly
affected by outliers and have small uncertainty even with a handful of runs.
Furthermore, to reveal the variability in performance across tasks, we propose
reporting performance distributions across all runs. Compared to prior work,
these distributions result in <em>performance profiles</em> that are statistically
unbiased, more robust to outliers, and require fewer runs for smaller
uncertainty.</p><table><thead><tr><th>Desideratum</th><th>Current Evaluation Protocol</th><th>Our Recommendation</th></tr></thead><tbody><tr><td>Uncertainty in aggregate performance</td><td><strong>Point estimates</strong><br>- Ignore statistical uncertainty<br>- Hinder <em>results reproducibility</em></td><td>Interval estimates via <strong>stratified bootstrap confidence intervals</strong></td></tr><tr><td>Variability in performance across tasks and runs</td><td><strong>Tables with mean scores per task</strong>&#171;br> - Overwhelming beyond a few tasks<br>- Standard deviations often omitted<br>- Incomplete picture for multimodal and heavy-tailed distributions</td><td><strong>Performance profiles</strong> (score distributions)<br>- Show tail distribution of scores on combined runs across tasks<br>- Allow qualitative comparisons<br>- Easily read any score percentile</td></tr><tr><td>Aggregate metrics for summarizing performance across tasks</td><td><strong>Mean</strong><br>- Often dominated by performance on outlier tasks<br><strong>Median</strong><br>- Requires large number of runs to claim improvements<br>- Poor indicator of overall performance: zero scores on nearly half the tasks do not affect it</td><td><strong>Interquartile Mean</strong> (IQM) across all runs<br>- Performance on middle 50% of combined runs<br>- Robust to outlier scores but more statistically efficient than median<br>To show other aspects of performance gains, report average <em>probability of improvement</em> and <em>optimality gap</em>.</td></tr></tbody></table><h2 id=formalism>Formalism</h2><p>We consider the setting in which a reinforcement learning algorithm is
evaluated on $M$ tasks. For each of these tasks, we perform $N$ independent
runs (A run can be different from using a fixed random seed. Indeed, fixing the
seed may not be able to control all sources of randomness such as
non-determinism of ML frameworks with GPUs) which each provide a scalar,
<em>normalized score</em> $x_{m,n}$, $m=1,\ldots ,M$ and $n=1,\ldots ,N$.
These normalized scores are obtained by linearly rescaling per-task scores
based on two reference points; for example, performance on the Atari games is
typically normalized with respect to a random agent and an average human, who
are assigned a normalized score of 0 and 1 respectively. We denote the set
of normalized scores by $x_{1:M,1:N}$.</p><p>In most experiments, there is inherent randomness in the scores obtained from
different runs. This randomness can arise from stochasticity in the task,
exploratory choices made during learning, randomized initial parameters, but
also software and hardware considerations such as non-determinism in GPUs and
in machine learning frameworks. Thus, we model the
algorithm&rsquo;s normalized score on the $m^{th}$ task as a real-valued random
variable $X_{m}$. Then, the score $x_{m, n}$ is a realization of the random
variable $X_{m,n}$, which is identically distributed as $X_{m}$. For
$\tau \in \mathbb{R}$, we define the tail distribution function of $X_m$ as
$F_m(\tau) = \Pr(X_m > \tau)$. For any collection of scores $y_{1:K}$,
the _empirical tail distribution function_ is given by
$\hat F(\tau; y_{1:K}) = \tfrac{1}{K} \sum_{k=1}^{K} \mathbb{1}[y_k > \tau]$.
In particular, we write $\hat{F}_m(\tau) = \hat F(\tau; x_{m, 1:N})$.</p><p>The <em>aggregate performance</em> of an algorithm maps the set of normalized
scores $x_{{1:M}, {1:N}}$ to a scalar value.
Two prevalent aggregate
performance metrics are the mean and median normalized scores. If we denote by
$\bar{x}_m = \tfrac{1}{N} \sum_{n=1}^N x_{m,n}$ the average score on task $m$
across $N$ runs, then these aggregate metrics are $\text{Mean}({\bar x}_{1:M})$
and $\text{Median}({\bar x}_{1:M})$.
More precisely, we call these _sample mean_ and _sample median_ over
the task means since they are computed from a finite set of $N$ runs. Since
$\bar{x}_m$ is a realization of the random variable
$\bar{X}_m = \tfrac{1}{N} \sum_{n=1}^N X_{m,n}$, the sample mean and median
scores are _point estimates_ of the random variables
$\text{Mean}({\bar X}_{1:M})$ and $\text{Median}({\bar X}_{1:M})$
respectively. We call _true mean_ and _true median_ the metrics that
would be obtained if we had unlimited experimental capacity ($N \to \infty$),
given by $\smash{\text{Mean}(\mathbb{E}{[X_{1:M}]})}$ and
$\smash{\text{Median}({\mathbb{E}[X_{1:M}]})}$ respectively.</p><p><strong>Confidence intervals</strong> (CIs) for a finite-sample score can be interpreted as
an estimate of plausible values for the true score. A $\alpha \times 100\%$ CI
computes an interval such that if we rerun the experiment and construct the CI
using a different set of runs, the fraction of calculated CIs (which would
differ for each set of runs) that contain the true score would tend towards
$\alpha \times 100\%$, where $\alpha \in [0, 1]$ is the nominal coverage rate.
95% CIs are typically used in practice. If the true score lies outside the
95% CI, then a sampling event has occurred which had a probability of 5% of
happening by chance.</p><p><strong>Remark</strong>. Following prior work, we recommend using confidence intervals for
measuring the uncertainty in results and showing effect sizes (e.g. performance
improvements over baseline) that are compatible with the given data.
Furthermore, we emphasize using statistical thinking but avoid statistical
significance tests (e.g. $p$-value &lt; $0.05$) because of their dichotomous
nature (significant versus not significant) and common
misinterpretations such as 1) lack of statistically significant results does
not demonstrate the absence of effect (see right panel of Figure 2, below),
and 2) given enough data, any trivial effect can be statistically
significant but may not be practically significant.</p><h2 id=case-study-the-atari-100k-benchmark>Case Study: The Atari 100k benchmark</h2><p>We begin with a case study to illustrate the pitfalls arising from the naive
use of point estimates in the few-run regime. Our case study concerns the Atari
100k benchmark, an offshoot of the ALE for evaluating
data-efficiency in deep RL. In this benchmark, algorithms are evaluated on only
100k steps (2-3 hours of game-play) for each of its 26 games, versus 200M
frames in the ALE benchmark.
Prior reported results on this benchmark have been computed mostly from 3 or
5 runs, and more rarely, 10 or 20 runs.</p><p>Our case study compares the performance of five recent deep RL algorithms,
namely: (1) <a href=https://arxiv.org/abs/1906.05243>DER</a>,
(2) <a href="https://openreview.net/forum?id=Bke9u1HFwB">OTR</a>,
(3) <a href="https://openreview.net/pdf?id=GY6-6sTvGaf">DrQ</a>,
(4) <a href=https://arxiv.org/abs/2004.04136>CURL</a>, and
(5) <a href=https://arxiv.org/abs/2007.05929>SPR</a>.
We chose these methods as representative of influential algorithms within this
benchmark. Since good performance on one game can result in unduly high sample
means without providing much information about performance on other games, it
is common to measure performance on Atari 100k using sample medians. Refer to
Appendix A.2 in the paper for more details about the experimental setup.</p><p>We investigate statistical variations in the few-run regime by evaluating 100
independent runs for each algorithm, where the score for a run is the average
returns obtained in 100 evaluation episodes taking place after training. Each
run corresponds to training one algorithm on each of the 26 games in Atari
100k. This provides us with $26 \times 100$ scores per algorithm, which we then
subsample with replacement to 3&ndash;100 runs. The subsampled scores are then used
to produce a collection of point estimates whose statistical variability can be
measured. We begin by using this experimental protocol to highlight statistical
concerns regarding median normalized scores.</p><p><strong>High variability in reported results.</strong>
Our first observation is that the sample medians reported in the literature
exhibit substantial variability when viewed as random quantities that depend on
a small number of sample runs (see left panel of figure below). This shows that
there is a fairly large potential for drawing erroneous conclusions based on
point estimates alone. As a concrete example, our analysis suggests that DER
may in fact be better than OTR, unlike what the reported point estimates
suggest. We conclude that in the few-run regime, point estimates are unlikely
to provide definitive answers to the question: &ldquo;Would we draw the same
conclusions were we to re-evaluate our algorithm with a different set of runs?&rdquo;</p><img src=/posts/research/rl/precipice/fig2.png alt="Distribution of median normalized scores" width=85% class=center><br><p><strong>Substantial bias in sample medians</strong>. The sample median is a biased
estimator of the true median:
$\mathbb{E}[\text{Median}({\bar X}_{1:M})] \neq \text{Median}(\mathbb{E}[X_{1:M}])$
in general. In the few-run regime, we find
that this bias can dominate the comparison between algorithms, as evidenced in
the figure below. For example, the score difference between sample
medians with 5 and 100 runs for SPR (+0.03 points) is about 36% of its mean
improvement over DRQ $(\varepsilon)$ (+0.08 points). Adding to the issue, the
magnitude and sign of this bias strongly depends on the algorithm being
evaluated.</p><img src=/posts/research/rl/precipice/fig3.png alt="Expected sample median of tasks" width=75% class=center><br><p><strong>Statistical concerns cannot be satisfactorily addressed with few runs.</strong>
While claiming improvements with 3 or fewer runs may naturally raise eyebrows,
folk wisdom in experimental RL suggests that 20 or 30 runs are enough. By
calculating 95% confidence interval (Specifically, we use the $m/n$
bootstrap to calculate the interval between $[2.5^{th}, 97.5^{th}]$ percentiles
of the distribution of sample medians (95% CIs).) on sample medians for a
varying number of runs (Figure 2 above, right), we find
that this number is closer to 50&ndash;100 runs in Atari 100k &ndash; far too many to be
computationally feasible for most research projects.</p><p>Consider a setting in which an algorithm is known to be better &ndash; what is the
reliability of median and <a href=#robust-and-efficient-aggregate-metrics>IQM</a> for
accurately assessing performance differences as the number of runs varies?
Specifically, we consider two identical $N$-run experiments involving SPR,
except that we artificially inflate one of the experiments' scores by a fixed
fraction or <em>lift</em> of $+\ell\%$ (see Figure 4 below). In particular,
$\ell = 0$ corresponds to running the same experiment twice but with different
runs. We find that statistically defensible improvements with median scores is
only achieved for 25 runs~($\ell=25$) and 100 runs ($\ell=10$). With
$\ell = 0$, even 100 runs are insufficient, with deviations of $20\%$ possible.</p><img src=/posts/research/rl/precipice/fig4.png alt="Detecting score lifts" width=55% class=center><br><p><strong>Changes in evaluation protocols invalidates comparisons to prior work.</strong>
A typical and relatively safe approach for measuring the performance of an RL
algorithm is to average the scores received in their final training episodes.
However, the field has seen a number of alternative protocols used, including
reporting the maximum evaluation score achieved during
training or across multiple runs. A similar protocol is also used by
CURL and <a href=https://arxiv.org/abs/2007.04938>SUNRISE</a> (See Appendix A.4 in paper).</p><p>Results produced under alternative protocols involving maximum are generally
incomparable with end-performance reported results. On Atari 100k, we find
that the two protocols produce substantially different
results (see Figure 5 below), of a magnitude greater than the
actual difference in score. In particular, evaluating DER with CURL&rsquo;s
protocol results in scores far above those reported for CURL. In other words,
this gap in evaluation procedures resulted in CURL being assessed as
achieving a greater true median than DER, where our experiment gives strong
support to DER being superior. Similarly, we find that a lot of SUNRISE&rsquo;s
improvement over DER can be explained by the change in evaluation protocol
(see Figure 5 below). Refer to
Appendix A.4 in the paper for discussion on pitfalls of
such alternative protocols.</p><img src=/posts/research/rl/precipice/fig5.png alt="Normalized DER scores with non-standard evaluation protocols" width=55% class=center><br><h2 id=recommendations-and-tools-for-reliable-evaluation>Recommendations and Tools for Reliable Evaluation</h2><p>Our case study shows that the increase in the number of runs required to
address the statistical uncertainty issues is typically infeasible for
computationally demanding deep RL benchmarks.
In this section, we identify three tools for improving the quality of
experimental reporting in the few-run regime, all aligned with the principle of
accounting for statistical uncertainty in results.</p><h3 id=stratified-bootstrap-confidence-intervals>Stratified Bootstrap Confidence Intervals</h3><p>We first reaffirm the importance of reporting interval estimates to indicate
the range within which an algorithm&rsquo;s aggregate performance is believed to lie.
Concretely, we propose using bootstrap CIs with
stratified sampling for aggregate performance, a method that can be applied to
small sample sizes and is better justified than reporting sample standard
deviations in this context.
While prior work has recommended using bootstrap CIs for reporting uncertainty
in single task mean scores with $N$ runs, this is less
useful when $N$ is small (see Figure A.18 below), as <em>bootstrapping</em>
assumes that re-sampling from the data approximates sampling from the true
distribution. We can do better by aggregating samples across tasks, for a total
of $MN$ random samples.</p><img src=/posts/research/rl/precipice/figa18.png alt="Validating 95\% bootstrap CIs for per-game mean scores" width=75% class=center><br><p>To compute the stratified bootstrap CIs, we re-sample runs with replacement
independently for each task to construct an empirical bootstrap sample with $N$
runs each for $M$ tasks from which we calculate a statistic and repeat this
process many times to approximate the sampling distribution of the statistic.
We measure the reliability of this technique in Atari 100k for variable $N$, by
comparing the nominal coverage of 95% to the &ldquo;true&rdquo; coverage from the
estimated CIs (see Figure 6 below) for different bootstrap
methods. We find that percentile CIs provide good interval estimates for as few
as $N=10$ runs for both median and <a href=#robust-and-efficient-aggregate-metrics>IQM</a> scores.</p><img src=/posts/research/rl/precipice/fig6.png alt="Validating 95\% stratistfied bootstrap CIs" width=35% class=center><br><h3 id=performance-profiles>Performance Profiles</h3><p>Most deep RL benchmarks yield scores that vary widely between tasks and may be
heavy-tailed, multimodal, or possess outliers (e.g. see Figure below). In this
regime, both point estimates, such as mean and median scores, and interval
estimates of these quantities paint an incomplete picture of an algorithm&rsquo;s
performance. Instead, we recommend the use of <em>performance profiles</em>, commonly
used in benchmarking optimization software. While performance profiles from
<a href=https://link.springer.com/article/10.1007/s101070100263>Dolan and Moré</a>
correspond to empirical cumulative distribution functions without any
uncertainty estimates, profiles proposed herein visualize the empirical tail
distribution function of a random score (higher curve is better),
with pointwise confidence bands based on stratified bootstrap.</p><p>By representing the entire set of normalized scores $x_{1:M, 1:N}$ visually,
performance profiles reveal performance variability across tasks much better
than interval estimates of aggregate metrics. Although tables containing
per-task mean scores and standard deviations can reveal this variability, such
tables tend to be overwhelming for more than a few tasks. In addition,
performance profiles are robust to outlier runs and insensitive to small
changes in performance across all tasks.</p><p>In this paper, we propose the use of a performance profile we call run-score
distributions or simply <em>score distributions</em>
(Figure 7 below, right), particularly well-suited to the
few-run regime. A score distribution shows the fraction of runs above a
certain normalized score and is given by</p><p>$$ \hat{F}_X(\tau) = \hat{F}(\tau; x_{1:M, 1:N}) = \frac{1}{M} \sum_{m=1}^{M} \hat{F}_m(\tau) = \frac{1}{M} \sum_{m=1}^{M} \frac{1}{N} \sum_{n=1}^{N} \mathbb{1}[x_{m,n} > \tau] $$</p><p>One advantage of the score distribution is that it is an unbiased estimator of
the underlying distribution
$F(\tau) = \tfrac{1}{N} \sum_{m=1}^{M} F_{m}(\tau)$.
Another advantage is that an outlier run with extremely high
score can change the output of score distribution for any $\tau$ by at most a
value of $\tfrac{1}{MN}$.</p><p>It is useful to contrast score distributions to average-score distributions,
originally proposed in the context of the ALE as a
generalization of the median score. Average-score distributions correspond to
the performance profile of a random variable $\bar{X}$,
$\hat{F}_{\bar{X}}(\tau) = \hat{F}(\tau; {\bar x}_{1:M})$,
which shows the fraction of tasks on which an
algorithm performs better than a certain score. However, such distributions
are a biased estimate of the thing they seek to represent. Run-score
distributions are more robust than average-score distributions, as they are a
step function in $1/MN$ versus $1/M$ intervals, and typically has less
variance: $\sigma_X^2 = \tfrac{1}{M^2N} \sum_{m=1}^{M} F_m(\tau)(1 -
F_m(\tau))$ versus $\sigma_{\bar X}^2 = \tfrac{1}{M^2}\sum_{m=1}^{M}
F_{\bar{X}_{m}}(\tau)(1 - F_{\bar{X}_m}(\tau))$. Figure 7 below
illustrates these differences.</p><img src=/posts/research/rl/precipice/fig7.png alt="Performance profiles on Atari 100k based on score distributions" width=75% class=center><br><h3 id=robust-and-efficient-aggregate-metrics>Robust and Efficient Aggregate Metrics</h3><p>Performance profiles allow us to compare different methods at a glance. If one
curve is strictly above another, the better method is said to
<em>stochastically dominate</em> the other. In RL benchmarks with a large
number of tasks, however, stochastic dominance is rarely observed: performance
profiles often intersect at multiple points. Finer quantitative comparisons
must therefore entail aggregate metrics.</p><p>We can extract a number of aggregate metrics from score distributions,
including median (mixing runs and tasks) and mean normalized scores (matching
our usual definition). As we already argued that these metrics are deficient,
we now consider interesting alternatives also derived from score distributions.</p><p>As an alternative to median, we recommend using the <strong>interquartile mean</strong> (IQM).
Also called 25% trimmed mean, IQM discards the bottom and top
$25\%$ of the runs and calculates the mean score of the remaining 50%
runs (=$\lfloor NM/2 \rfloor$ for $N$ runs each on $M$ tasks). IQM interpolates between
mean and median across runs, which are 0% and almost $50%$ trimmed means
respectively. Compared to sample median, IQM is a better indicator of overall
performance as it is calculated using 50% of the combined runs while median
only depends on the performance ordering across tasks and not on the magnitude
except at most 2 tasks. For example, zero scores on nearly half of the tasks
does not affect the median while IQM exhibits a severe degradation. Compared to
mean, IQM is robust to outliers, yet has considerably less bias than
median (see Figure A.17 below). While median is more robust to outliers than
IQM, this robustness comes at the expense of statistical efficiency, which is
crucial in the few-run regime: IQM results in much smaller
CIs (Figure 2 (right) and Figure 6) and is able to detect a given improvement with far
fewer runs (Figure 4).</p><img src=/posts/research/rl/precipice/figa17.png alt="Negligible bias in IQM scores" width=75% class=center><br><p>As a robust alternative to mean, we recommend using the <strong>optimality gap</strong>:
the amount by which the algorithm fails to meet a minimum score of
$\gamma = 1.0$ (orange region in Figure 8 below). This assumes
that a score of 1.0 is a desirable target beyond which improvements are not
very important, for example when the aim is to obtain human-level
performance. Naturally, the threshold $\gamma$ may be chosen differently,
which we discuss further in Appendix A.7 in the paper.</p><img src=/posts/research/rl/precipice/fig8.png alt="Aggregate metrics" width=25% class=center><br><p>If one is interested in knowing how robust an improvement from an algorithm $X$
over an algorithm $Y$ is, another possible metric to consider is the average
<strong>probability of improvement</strong> &ndash; this metric shows how likely it is for
$X$ to outperform $Y$ on a randomly selected task. Specifically,
$P(X > Y) = \tfrac{1}{M} \sum_{m=1}^{M} P(X_m > Y_m)$,
where $P(X_m > Y_m)$ (Equation A.2 in paper) is the probability that $X$ is better
than $Y$ on task $m$. Note that, unlike IQM and optimality gap, this metric
does not account for the size of improvement. While finding the best aggregate
metric is still an open question and is often dependent on underlying
normalized score distribution, our proposed alternatives avoid the failure
modes of prevalent metrics while being robust and requiring fewer runs to
reduce uncertainty.</p><h2 id=re-evaluating-evaluation-on-deep-rl-benchmarks>Re-evaluating Evaluation on Deep RL Benchmarks</h2><h3 id=arcade-learning-environment>Arcade Learning Environment</h3><p>Training RL agents for 200M frames on the
ALE is the most widely recognized benchmark in deep RL. We revisit some popular
methods which demonstrated progress on this benchmark and reveal discrepancies
in their findings as a consequence of ignoring the uncertainty in their
results (Figure 9 below). For example,
<a href=https://arxiv.org/abs/2010.02193>DreamerV2</a> exhibits a large amount of uncertainty in
aggregate scores. While <a href=https://arxiv.org/abs/2007.14430>M-IQN</a> claimed better
performance than Dopamine Rainbow (Dopamine Rainbow differs from
<a href=https://arxiv.org/abs/1710.02298>the original</a>
by not including double DQN, dueling architecture
and noisy networks. Also, results in
<a href=https://arxiv.org/abs/1710.02298>the original Rainbow paper</a> were reported
using a single run without sticky actions.) in terms
of median normalized scores, their interval estimates strikingly overlap.
Similarly, while <a href=https://arxiv.org/abs/1707.06887>C51</a> is considered
substantially better than <a href=https://www.nature.com/articles/nature14236>DQN</a>,
the interval estimates as well as performance profiles for DQN (Adam) and C51
overlap significantly.</p><img src=/posts/research/rl/precipice/fig9.png alt="Aggregate metrics on Atari 200M" width=75% class=center><br><p>Figure 9 below reveals an interesting limitation of aggregate metrics:
depending on the choice of metric, the ordering between algorithms changes
(e.g. Median vs. IQM). The inconsistency in ranking across aggregate metrics
arises from the fact that such metrics only capture a specific aspect of
overall performance across tasks and runs. Additionally, the change of
algorithm ranking between optimality gap and IQM/median scores reveal that
while recent algorithms typically show performance gains relative to humans on
average, their performance seems to be worse on games below human performance.
Since performance profiles capture the full picture, they would often
illustrate why such inconsistencies exist. For example, optimality gap and IQM
can be both read as areas in the profile (Figure 8). The
performance profile in Figure 10 (left) illustrates
the nuances present when comparing different algorithms. For example, IQN
seems to be better than Rainbow for $\tau \geq 2$, but worse for $\tau &lt; 2$.
Similarly, the profiles of DreamerV2 and M-IQN for $\tau &lt; 8$ intersect at
multiple points. To compare sample efficiency of the agents, we also present
their IQM scores as a function of number of frames in
Figure 10 (right).</p><img src=/posts/research/rl/precipice/fig10.png alt="Atari 200M evaluation" width=75% class=center><br><h3 id=deepmind-control-suite>DeepMind Control Suite</h3><p>Recent continuous control papers benchmark
performance on 6 tasks in <a href=https://github.com/deepmind/dm_control>DM Control</a>
at 100k and 500k steps. Typically, such papers claim improvement based on
higher mean scores per task regardless of the variability in those scores.
However, we find that when accounting for uncertainty in results, most
algorithms do not consistently rank above algorithms they claimed to improve
upon (Figure 11c and 11b).
Furthermore, there are huge overlaps in 95% CIs of mean normalized scores for
most algorithms (Figure 11a). These findings suggest that a
lot of the reported improvements are spurious, resulting from randomness in the
experimental protocol.</p><img src=/posts/research/rl/precipice/fig11.png alt="DeepMind Control Suite evaluation" width=75% class=center><br><h3 id=procgen-benchmark>Procgen benchmark</h3><p><a href=https://arxiv.org/abs/1912.01588>Procgen</a> is a popular benchmark, consisting
of 16 diverse tasks, for evaluating generalization in RL.
Recent papers report mean
PPO-normalized scores on this benchmark to emphasize the gains relative to
<a href=https://arxiv.org/abs/1707.06347>PPO</a> as most methods are built on top of it.
However, Figure 12 (left) shows that PPO-normalized scores typically
have a heavy-tailed distribution making the mean scores highly dependent on
performance on a small fraction of tasks.</p><img src=/posts/research/rl/precipice/fig12.png alt="Procgen evaluation results" width=75% class=center><br><p>Instead, we recommend using
normalization based on the estimated minimum and maximum scores on
ProcGen and reporting aggregate metrics based on
such scores (Figure A.32 below).</p><img src=/posts/research/rl/precipice/figa32.png alt="Aggregate metrics on Procgen" width=75% class=center><br><p>While publications sometimes make binary claims about whether they improve over
prior methods, such improvements are inherently probabilistic. To reveal this
discrepancy, we investigate the following question: &ldquo;What is the probability
that an algorithm which claimed improvement over a prior algorithm performs
better than it?&rdquo; (Figure 12, right). While this probability does
not distinguish between two algorithms which uniformly improve on all tasks by
1% and 100%, it does highlight how likely an improvement is. For example,
there is only a $40-50$% chance that <a href=https://arxiv.org/abs/2006.12862>UCB-DrAC</a>
improves upon <a href=https://arxiv.org/abs/2010.03934>PLR</a>. We note that a number of
improvements reported in the existing literature are only $50-70$% likely.</p><h2 id=discussion>Discussion</h2><p>We saw, both in our case study on the Atari 100k benchmark and with our
analysis of other widely-used RL benchmarks, that statistical issues can have a
sizeable influence on reported results, in particular when point estimates are
used or evaluation protocols are not kept constant within comparisons. Despite
earlier calls for more experimental rigor in deep RL, our
analysis shows that the field has not yet found sure footing in this regards.</p><p>In part, this is because the issue of reproducibility is a complex one; where
our work is concerned with our confidence about and interpretation of reported
results (what <a href=https://www.science.org/doi/10.1126/scitranslmed.aaf5027>Goodman et al.</a>
calls <em>results reproducibility</em>),
others have highlighted that there might be missing
information about the experiments themselves (<em>methods reproducibility</em>).
We remark that the problem is not solved by fixing random seeds, as has
sometimes been proposed, since it does not really address the question of
whether an algorithm would perform well under similar conditions but with
different seeds. Furthermore, fixed seeds might benefit certain algorithms more
than others. Nor can the problem be solved by the use of dichotomous
statistical significance tests, as discussed <a href=#formalism>above</a>.</p><p>One way to minimize the risks associated with statistical effects is to report
results in a more complete fashion, paying close attention to bias and
uncertainty within these estimates. To this end, our recommendations are
summarized in Table 1 <a href=#introduction>above</a>. To further support RL researchers
in this endeavour, we released an easy-to-use Python library,
<a href=https://github.com/google-research/rliable>RLiable</a> along with
a <a href="https://colab.research.google.com/drive/1ZmIhLVfxbj6ATIBg97RBJhFNs-6QWrik#scrollTo=CJzoQDw3zXtN">Colab notebook</a>
for implementing
our recommendations, as well as all the individual
<a href=https://console.cloud.google.com/storage/browser/rl-benchmark-data/>runs</a>
used in our experiments. Again, we emphasize the importance of published
papers providing results for all runs to allow for future statistical analyses.</p><p>A barrier to adoption of evaluation protocols proposed in this work, and more
generally, rigorous evaluation, is whether there are clear incentives for
researchers to do so, as more rigor generally entails more nuanced and tempered
claims. Arguably, doing good and reproducible science is one such incentive. We
hope that our findings about erroneous conclusions in published papers would
encourage researchers to avoid fooling themselves, even if that requires
tempered claims. That said, a more pragmatic incentive would be if conferences
and reviewers required more rigorous evaluation for publication, e.g. NeurIPS
2021 checklist asks whether error bars are reported. Moving towards reliable
evaluation is an ongoing process and we believe that this paper would greatly
benefit it.</p><p>Given the substantial influence of statistical considerations in experiments
involving 40-year old Atari 2600 video games and low-DOF robotic simulations,
we argue that it is unlikely that an increase in available computation will
resolve the problem for the future generation of RL benchmarks. Instead, just
as a well-prepared rock-climber can skirt the edge of the steepest precipices,
it seems likely that ongoing progress in reinforcement learning will require
greater experimental discipline.</p></div><div class=btn-improve-page><a href=https://github.com/psc-g/psc-g.github.io/edit/master/content/posts/research/rl/precipice.md><i class="fas fa-code-branch"></i>Improve this page</a></div><hr><div class="row next-prev-navigator"><div class="col-md-6 previous-article"><a href=/posts/musicode/hallelagine/ class="btn btn-outline-info"><span><i class="fas fa-chevron-circle-left"></i>Prev</span><br><span>Portrait of Hallelagine</span></a></div><div class="col-md-6 next-article"><a href=/posts/research/rl/tandem/ class="btn btn-outline-info"><span>Next <i class="fas fa-chevron-circle-right"></i></span><br><span>The Difficulty of Passive Learning in Deep Reinforcement Learning</span></a></div></div><hr><div id=disqus_thread></div><script type=text/javascript>(function(){if(window.location.hostname=="localhost")return;var dsq=document.createElement("script");dsq.type="text/javascript";dsq.async=true;var disqus_shortname="does-not-exist";dsq.src="//"+disqus_shortname+".disqus.com/embed.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(dsq);})();</script><noscript>Please enable JavaScript to view the
<a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com/ class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></div></div></section><section class=toc-section id=toc-section><div class=toc-holder><h5 class="text-center pl-3">Table of Contents</h5><hr><div class=toc><nav id=TableOfContents><ul><li><a href=#introduction>Introduction</a></li><li><a href=#formalism>Formalism</a></li><li><a href=#case-study-the-atari-100k-benchmark>Case Study: The Atari 100k benchmark</a></li><li><a href=#recommendations-and-tools-for-reliable-evaluation>Recommendations and Tools for Reliable Evaluation</a><ul><li><a href=#stratified-bootstrap-confidence-intervals>Stratified Bootstrap Confidence Intervals</a></li><li><a href=#performance-profiles>Performance Profiles</a></li><li><a href=#robust-and-efficient-aggregate-metrics>Robust and Efficient Aggregate Metrics</a></li></ul></li><li><a href=#re-evaluating-evaluation-on-deep-rl-benchmarks>Re-evaluating Evaluation on Deep RL Benchmarks</a><ul><li><a href=#arcade-learning-environment>Arcade Learning Environment</a></li><li><a href=#deepmind-control-suite>DeepMind Control Suite</a></li><li><a href=#procgen-benchmark>Procgen benchmark</a></li></ul></li><li><a href=#discussion>Discussion</a></li></ul></nav></div></div></section></div><footer class="container-fluid text-center align-content-center footer pb-2"><div class="container pt-5"><div class="row text-left"><div class="col-md-4 col-sm-12"><h5>Navigation</h5><ul><li class=nav-item><a class=smooth-scroll href=#about>About</a></li><li class=nav-item><a class=smooth-scroll href=#recent-posts>Recent Posts</a></li><li class=nav-item><a class=smooth-scroll href=#publications>Publications</a></li></ul></div><div class="col-md-4 col-sm-12"><h5>Contact me:</h5><ul><li><span><a href=https://twitter.com/@pcastr target=_blank>Twitter <i class="fab fa-twitter"></i></a></span></li></ul></div></div></div><hr><div class=container><div class="row text-left"><div class=col-md-4><a id=theme href=https://github.com/hossainemruz/toha target=#><img src=/assets/images/inverted-logo.png>
Toha</a></div><div class="col-md-4 text-center">© 2020 Copyright.</div><div class="col-md-4 text-right"><a id=hugo href=https://gohugo.io/>Powered by
<img src=/assets/images/hugo-logo-wide.svg alt="Hugo Logo" height=18></a></div></div></div></footer><script src=/assets/js/jquery-3.4.1.min.js></script><script src=/assets/js/popper.min.js></script><script src=/assets/js/bootstrap.min.js></script><script src=/assets/js/navbar.js></script><script src=/assets/js/main.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js></script><script src=/assets/js/single.js></script><script>hljs.initHighlightingOnLoad();</script></body></html>