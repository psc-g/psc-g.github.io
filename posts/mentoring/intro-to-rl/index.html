<!doctype html><html><head><title>Introduction to reinforcement learning</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="ie=edge"><link rel=stylesheet href=/assets/css/bootstrap.min.css><link rel=stylesheet href=/assets/css/layouts/main.css><link rel=stylesheet href=/assets/css/style.css><link rel=stylesheet href=/assets/css/navigators/navbar.css><link href="https://fonts.googleapis.com/css2?family=Muli:wght@300;400;500;600" rel=stylesheet><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.min.css><link rel=icon type=image/png href=/assets/images/psc_emoji.png><link rel=stylesheet href=/assets/css/style.css><script>MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']],processEscapes:true,processEnvironments:true},options:{skipHtmlTags:['script','noscript','style','textarea','pre']}};window.addEventListener('load',(event)=>{document.querySelectorAll("mjx-container").forEach(function(x){x.parentElement.classList+='has-jax'})});</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><meta name=description content="Introduction to reinforcement learning"><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/atom-one-dark.min.css><link rel=stylesheet href=/assets/css/layouts/single.css><link rel=stylesheet href=/assets/css/navigators/sidebar.css><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-XXXXXXXXX-X','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script></head><body data-spy=scroll data-target=#TableOfContents data-offset=80><div class="container-fluid bg-dimmed wrapper"><nav class="navbar navbar-expand-xl top-navbar final-navbar shadow"><div class=container><button class="navbar-toggler navbar-light" id=sidebar-toggler type=button onclick=toggleSidebar()>
<span class=navbar-toggler-icon></span></button>
<a class=navbar-brand href=/><img src=/assets/images/psc_emoji.png>psc's website</a>
<button class="navbar-toggler navbar-light" id=toc-toggler type=button onclick=toggleTOC()>
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse lang-selector" id=top-nav-items><ul class="navbar-nav ml-auto"></ul></div></div><img src=/assets/images/psc_emoji.png class=d-none id=main-logo>
<img src=/assets/images/psc_emoji.png class=d-none id=inverted-logo></nav><section class=sidebar-section id=sidebar-section><div class=sidebar-holder><div class=sidebar id=sidebar><input type=text placeholder=Search data-search id=search-box><div class=sidebar-tree><ul class=tree id=tree><li id=list-heading><a href=/posts data-filter=all>Posts</a></li><div class=subtree><li><i class="fas fa-minus-circle"></i><a class=active href=/posts/mentoring/>Mentoring / Education</a><ul class=active><li><a href=/posts/mentoring/gridworldplayground/>GridWorld Playground</a></li><li><a class=active href=/posts/mentoring/intro-to-rl/>Intro to RL</a></li><li><a href=/posts/mentoring/resume/>Preparing your resume</a></li><li><a href=/posts/mentoring/interviewing/>Tips for Interviewing at Google</a></li><li><a href=/posts/mentoring/reviewing/>Tips for Reviewing Research Papers</a></li></ul></li><li><i class="fas fa-plus-circle"></i><a href=/posts/musicode/>MUSICODE</a><ul><li><i class="fas fa-plus-circle"></i><a href=/posts/musicode/phase1/>Phase 1</a><ul><li><a href=/posts/musicode/phase1/introducing/>0-Introducing</a></li><li><a href=/posts/musicode/phase1/episode1/>1-Musical Note & Computation</a></li><li><a href=/posts/musicode/phase1/episode2/>2-Bits & Semitones</a></li><li><a href=/posts/musicode/phase1/episode3/>3-Leitmotifs & Variables</a></li><li><a href=/posts/musicode/phase1/episode4/>4-Live Coding & Jazz</a></li><li><a href=/posts/musicode/phase1/episode5/>5-Repeats & Loops</a></li></ul></li><li><a href=/posts/musicode/introducing/>Introducing</a></li><li><a href=/posts/musicode/ldd/>Losses, Dissonances, and Distortions</a></li></ul></li><li><i class="fas fa-plus-circle"></i><a href=/posts/art/>Art</a><ul><li><a href=/posts/art/cost-of-beauty/>Cost of Beauty</a></li><li><a href=/posts/art/covid-music/>Covid Music</a></li><li><a href=/posts/art/family/>Family</a></li><li><a href=/posts/art/jidiji/>JiDiJi</a></li><li><a href=/posts/art/musical-aquarium/>Musical Aquarium</a></li></ul></li><li><i class="fas fa-plus-circle"></i><a href=/posts/misc/>Misc</a><ul><li><a href=/posts/misc/agr/>Artificial General Relativity</a></li><li><a href=/posts/misc/origins/>Origins of April Fool's Day</a></li></ul></li><li><i class="fas fa-plus-circle"></i><a href=/posts/research/>Research</a><ul><li><i class="fas fa-plus-circle"></i><a href=/posts/research/other/>Other</a><ul><li><a href=/posts/research/other/rigl/rigl/>RigL</a></li></ul></li><li><i class="fas fa-plus-circle"></i><a href=/posts/research/rl/>RL</a><ul><li><a href=/posts/research/rl/2020highlights/>2020 RL Highlights</a></li><li><a href=/posts/research/rl/pse/>Contrastive Behavioral Similarity Embeddings</a></li><li><a href=/posts/research/rl/dopamine/>Dopamine</a></li><li><a href=/posts/research/rl/loon/>Flying balloons with RL</a></li><li><a href=/posts/research/rl/metrics_continuity/>Metrics & continuity in RL</a></li><li><a href=/posts/research/rl/mico/>MICo</a></li><li><a href=/posts/research/rl/revisiting_rainbow/>Revisiting Rainbow</a></li><li><a href=/posts/research/rl/scalable/>Scalable methods ...</a></li><li><a href=/posts/research/rl/precipice/>Statistical Precipice</a></li><li><a href=/posts/research/rl/tandem/>Tandem RL</a></li></ul></li><li><i class="fas fa-plus-circle"></i><a href=/posts/research/creativity/>Creativity</a><ul><li><a href=/posts/research/creativity/agence/>Agence, a dynamic film</a></li><li><a href=/posts/research/creativity/ganterpretations/>GANterpretations</a></li><li><a href=/posts/research/creativity/ml-jam/>ML-Jam</a></li></ul></li></ul></li></div></ul></div></div></div></section><section class=content-section id=content-section><div class=content><div class="container p-0 read-area"><div class="hero-area col-sm-12" id=hero-area style=background-image:url(https://psc-g.github.io/posts/mentoring/intro-to-rl/cartpole.gif)></div><div class=page-content><div class="author-profile ml-auto align-self-lg-center"><img class=rounded-circle src=/assets/images/psc_gradient.png><h5 class=author-name>Pablo Samuel Castro</h5><p>October 14, 2020</p></div><div class=title><h1>Introduction to reinforcement learning</h1></div><div class=post-content id=post-content><p>This post is based on <a href="https://colab.research.google.com/github/psc-g/intro_to_rl/blob/master/Introduction_to_reinforcement_learning.ipynb#scrollTo=XVrlWe2YPpXt">this colab</a>.</p><p>You can also watch a video where I go through the basics <a href=https://youtu.be/xMZE-9WECQE>here</a>.</p><p>Pueden ver un video (en español) donde presento el material <a href=https://youtu.be/ZOaA4svJH3U>aquí</a>.</p><h2 id=introduction>Introduction</h2><p>Reinforcement learning methods are used for sequential decision making in uncertain environments. It is typically framed as an agent (the learner) interacting with an environment which provides the agent with reinforcement (positive or negative), based on the agent&rsquo;s decisions. The agent leverages this reinforcement to update its behaviour in an aim to get closer to acting optimally. In interacting with the uncertain environment, the agent is also learning about the dynamics of the underlying system.</p><p>The following image depicts the typical flow of a reinforcement learning problem.</p><ul><li>An agent, at some state in the environment, sends an action to the environment</li><li>The environment responds by providing the agent with:<ul><li>A reward/cost that depends on the state the agent was in and the action chosen</li><li>A new state that the agent transitions to after performing the selected action (which can sometimes be the same state the agent was already in).</li></ul></li><li>The agent then uses this information to update its behaviour so that it increases the likelihood of choosing actions that give a positive reward, and reduces the likelihood of choosing actions that result in a penalty.</li></ul><img src=/posts/mentoring/intro-to-rl/generalRL.png alt="General RL" width=50% class=center><p>This notebook provides a brief introduction to reinforcement learning, eventually ending with an exercise to train a deep reinforcement learning agent with the <a href=https://github.com/google/dopamine>dopamine framework</a>.</p><p>The notebook is roughly organized as follows:</p><ol><li>A simple motivating example is presented to illustrate some of the main points and challenges.</li><li>Markov decision processes (MDPs), the mathematical formalism used to express these problems, is introduced.</li><li>Exact tabular methods are presented, which can be used when the environment is fully known. These methods form the foundation for the learning algorithms in uncertain environments.</li><li>Value-based learning algorithms are introduced, and related algorithms are also presented.</li><li>The methods introduced are put to the test on a simple MDP.</li><li>Deep reinforcement learning is introduced, along with some implementation details.</li><li>We use deep reinforcement learning to learn a policy on a larger MDP.</li><li>Resources for further study are provided.</li></ol><h2 id=a-motivating-example>A motivating example</h2><p>Consider the following simple grid where the agent (the blue circle) must navigate to the gold star by choosing from four actions at each grid cell (up, down, left, right):</p><img src=/posts/mentoring/intro-to-rl/gridWorldExample.png alt="GridWorld example" width=25% class=center><p>Being able to see the whole grid, it is trivial for us to find a shortest path to the gold star (the optimal policy for the agent):</p><img src=/posts/mentoring/intro-to-rl/gridWorldPolicy.png alt="GridWorld policy" width=25% class=center><p>In reinforcement learning problems, however, we typically do not have immediate access to the environment. In our simple example, the agent may simply know the number of cells in the grid, but may not have any information on what is contained in each:</p><img src=/posts/mentoring/intro-to-rl/gridWorldUncertain.png alt="GridWorld uncertain" width=25% class=center><p>The agent must then explore the environment by taking actions and keeping track of what is encountered at the different cells:</p><img src=/posts/mentoring/intro-to-rl/gridWorldPartiallyExplored.png alt="GridWorld partially explored" width=25% class=center><p>In the previous image, the grey arrows represent the actions that the agent has already taken in each of those cells. It benefits the agent to keep track of these so as to remember both the actions that lead to rewards and those that lead to penalties.</p><p>To anticipate some of the concepts that will be formalized below, the grid represents the environment. This environment consists of:</p><ul><li>A set of states (the grid cells)</li><li>A set of possible actions (up, down, left, right)</li><li>Transition dynamics, defining the effect of the actions (e.g. taking the right action will take the agent to the cell to the right of its current state)</li><li>A reward signal that indicates the benefit or cost of the action just taken (e.g. the gold star is a positive reward received upon entering the bottom-right state).</li></ul><p>The agent is typically aware of the states and actions, but not of the transition dynamics nor reward signal. Thus, the agent make use of a method that:</p><ul><li>Will explore the environment to learn about the transition and reward dynamics.</li><li>Will keep track of previously visited states and the actions performed therein, which can be used to inform future action choices.</li><li>Can balance exploring new experiences and exploiting the knowledge it has already achieved.</li></ul><p>This last point is the &ldquo;exploit-explore dilemma&rdquo;, which is a central (and open!) problem in reinforcement learning. How to best balance this tradeoff in a computationally efficient manner is the subject of active research.</p><p>To illustrate its importance, assume the agent encountered a small reward in the grid. If at that point the agent were to decide to purely exploit its current knowledge, it would settle on the policy below, without ever exploring the unknown area where a larger reward awaits:</p><img src=/posts/mentoring/intro-to-rl/gridWorldSuboptimalPolicy.png alt="GridWorld suboptimal policy" width=25% class=center><p>Having finished this motivating example, we are now ready to dive into the mathematical details.</p><h2 id=markov-decision-processes>Markov decision processes</h2><p>More formally, the problem is typically expressed as a Markov decision process
$\langle\mathcal{S},\mathcal{A},R,P,\gamma\rangle$, where:</p><ul><li>$\mathcal{S}$ is a finite set of <em>states</em> that the agent &ldquo;inhabits&rdquo;. You can also consider continuous state spaces, but for this notebook we will only be considering the finite kind.</li><li>$\mathcal{A}$ is a finite set of <em>actions</em> that the agent can perform from each state. In the vast majority of cases, it is assumed that all actions are available in all states. Action spaces can also be continuous, but we will be limiting ourselves to finite action spaces in this notebook.</li><li>$R:\mathcal{S}\times\mathcal{A}\rightarrow [R_{min}, R_{max}]\subset\mathbb{R}$ is a bounded reward (or cost) function which provides the agent with (positive or negative) reinforcement.</li><li>$P:\mathcal{S}\times\mathcal{A}\rightarrow\Delta(\mathcal{S})$ encodes the transition dynamics, where $P(s, a)(s')$ is the probability of ending in state $s'$ after taking action $a$ from state $s$.</li><li>$\gamma\in[0, 1)$ is a discount factor.</li></ul><p>The notation $\Delta(X)$ stands for the set of probability distributions over a set $X$.</p><p>Since the discount factor $\gamma$ is strictly less than $1$, it encourages the agent to accumulate rewards as quickly as possible. In the motivating example above, it means the optimal policy is also the shortest path to the big star. Having $\gamma = 1$ would mean that the agent perceives no difference between taking a short or long path to the gold star.</p><p>The agent interacts with the environment in discrete time steps. If at time step $t$ the agent is in state $s_t$ and chooses action $a_t$, the environment responds with a new state $s_{t+1}\sim P(s_t, a_t)$ and a reward $R(s_t, a_t)$.</p><h3 id=policies-and-value-functions>Policies and value functions</h3><p>A policy $\pi$ is a mapping from states to a distribution over actions: $\pi:\mathcal{S}\rightarrow\Delta(\mathcal{A})$, and encodes the agent&rsquo;s <em>behaviour</em>. The <em>value</em> of a policy $\pi$ from an initial state $s_0$ is encoded as:</p><p>$V^{\pi}(s_0) = \left[\sum_{t=0}^{\infty}\gamma^t R(s_t, a_t) | a_t\sim\pi(s_t),s_{t+1}\sim P(s_t, a_t)\right]$</p><p>This is quantifying the expected sum of discounted rewards when starting from state $s_0$ and following policy $\pi$. It turns out we can express value functions for any state $s$ via the recurrence:</p><p>$V^{\pi}(s) = \mathbb{E}_{a\sim\pi(s)}\left[R(s, a) + \gamma\mathbb{E}_{s'\sim P(s, a)}[V^{\pi}(s')]\right]$</p><p>or equivalently, replacing the expectation over actions with a summation:</p><p>$V^{\pi}(s) = \sum_{a\in\mathcal{A}}\pi(s)(a)\left[R(s, a) + \gamma\sum_{s'\in\mathcal{S}} P(s, a)(s')V^{\pi}(s')\right]$</p><p>We may sometimes also be interested in the value of performing action $a$ from state $s$, and <em>then</em> following policy $\pi$:</p><p>$Q^{\pi}(s, a) = R(s, a) + \gamma\mathbb{E}_{s'\sim P(s, a)}[V^{\pi}(s')]$</p><h3 id=optimal-policies-and-value-functions>Optimal policies and value functions</h3><p>The goal of the agent is to find a policy $\pi^<em>$ that dominates all other policies: $V^</em> := V^{\pi^*} \geq V^{\pi}$ for all $\pi$. It turns out that there is always a deterministic policy that achieves the optimum. The Bellman optimality equations express this via the recurrence:</p><p>$V^*(s) = \max_{a\in\mathcal{A}}\left[R(s, a) + \gamma\sum_{s'\in\mathcal{S}} P(s, a)(s')V^*(s')\right]$</p><p>The state-action value function can be defined in a similar way as above:</p><p>$Q^*(s, a) = R(s, a) + \gamma\mathbb{E}_{s'\sim P(s, a)}[V^*(s')]$</p><p>Clearly, we can compute $Q^*$ from $V^*$, and once we know $Q^*$ we can find $\pi^*$ via:</p><p>$\pi^*(s) = \arg\max_{a\in\mathcal{A}}Q^*(s, a)$</p><p>The important question, then, is <em>how</em> do we find $\pi^*$, $V^*$, and/or $Q^*$? Read on and find out!</p><p>To begin with, run the first two cells below to install and import all necessary packages.</p><h2 id=computing-the-optimal-value-exactly>Computing the optimal value exactly</h2><p>If we have access to $P$ and $R$, then we can compute $V^*$ in a few ways. We will explore two common methods here:</p><ul><li>Value iteration</li><li>Policy iteration</li></ul><p>When the transition and reward dynamics are known, these problems are typically referred to as <em>planning</em> problems, which has its own field of active research. In this scenario, the &ldquo;agent&rdquo; does not need to interact with an environment to gather information for improving its policy. There is a close relationship between planning and reinforcement learning, and many lines of research sit at their intersection.</p><p>For our purposes, it will be useful to review some solutions to the planning problem, as they will serve as foundations for the learning algorithms we present further down.</p><h3 id=value-iteration>Value iteration</h3><p>In Value iteration we are continuously updating an estimate $V_{t+1}$ by leveraging our previous estimate $V_t$.</p><p>$V_{t+1}(s) := \max_{a\in\mathcal{A}} \left[ R(s, a) + \gamma \sum_{s'\in\mathcal{S}}P(s, a)(s') V_t(s') \right]$</p><p>This is typically referred to as the <em>Bellman backup</em>. It can be shown that, starting from an initial estimate $V_0$, $\lim_{t\rightarrow\infty}V_t = V^*$.</p><p>This gives us the value iteration algorithm:</p><ol><li>Initialize $V\equiv 0$</li><li>Loop until convergence:<ul><li>For every $s\in\mathcal{S}$:<br>$V(s)\leftarrow \max_{a\in\mathcal{A}} \left[ R(s, a) + \gamma \sum_{s'\in\mathcal{S}}P(s, a)(s') V(s') \right]$</li></ul></li><li>Return $V$</li></ol><p>It will be useful to think of the functions above as vectors, which then allows
us to do the Bellman backup with matrix operations. If we assume our matrices have the following shapes:</p><pre><code>P.shape = [num_states, num_actions, num_states]
R.shape = [num_states, num_actions]
V.shape = [num_states]
Q.shape = [num_states, num_actions]
</code></pre><p>Then we can compute $V$ with two lines of <code>numpy</code> code:</p><pre><code>import numpy as np
Q = R + gamma * np.matmul(P, V)
V = np.max(Q, axis=1)
</code></pre><p>Alternatively, we can use the <a href=https://numpy.org/doc/stable/reference/generated/numpy.einsum.html>einsum</a> function, which can help clarify the dimensions along which the multiplication is happening:</p><pre><code>Q = R + gamma * np.einsum('sat,t-&gt;sa', P, V)
V = np.max(Q, axis=1)
</code></pre><p>As mentioned above, once we have $V^*$, we can compute $Q^*$ and $\pi^*$.</p><p>The code cell below is an implementation of value iteration.</p><pre><code>def value_iteration(P, R, gamma, tolerance=1e-3):
  &quot;&quot;&quot;Find V* using value iteration.

  Args:
    P: numpy array defining transition dynamics. Shape: |S| x |A| x |S|.
    R: numpy array defining rewards. Shape: |S| x |A|.
    gamma: float, discount factor.
    tolerance: float, tolerance level for computation.

  Returns:
    V*: numpy array of shape ns.
    Q*: numpy array of shape ns x na.
  &quot;&quot;&quot;
  assert P.shape[0] == P.shape[2]
  assert P.shape[0] == R.shape[0]
  assert P.shape[1] == R.shape[1]
  ns = P.shape[0]
  na = P.shape[1]
  V = onp.zeros(ns)
  Q = onp.zeros((ns, na))
  error = tolerance * 2
  while error &gt; tolerance:
    # This is the Bellman backup (onp.einsum FTW!).
    Q = R + gamma * onp.einsum('sat,t-&gt;sa', P, V)
    new_V = onp.max(Q, axis=1)
    error = onp.max(onp.abs(V - new_V))
    V = onp.copy(new_V)
  return V, Q
</code></pre><h3 id=policy-iteration>Policy iteration</h3><p>Instead of iterating over $V_t$, we can iterate over $\pi_t$ and stop once the
policy is no longer changing. The algorithm proceeds as follows:</p><ol><li>Initialize $\pi$ arbitrarily. For simplicity we will assume it is a matrix of shape <code>[num_states, num_actions]</code> with only one <code>1.0</code> for each row (i.e. a deterministic policy).</li><li>While $\pi$ is changing:<ul><li>$Q(s, a) = R(s, a) + \gamma\sum_{s'\in\mathcal{S}}P(s, a)(s')Q(s', \pi(s'))$</li><li>$\pi(s) = \arg\max Q(s, \cdot)$</li></ul></li><li>$Q(s, a) = R(s, a) + \gamma\sum_{s'\in\mathcal{S}}P(s, a)(s')Q(s', \pi(s'))$</li><li>$V(s) = \max_{a\in\mathcal{A}}Q(s, a)$</li><li>Return $V$</li></ol><p>Notice that, in contrast to value iteration, here we compute $Q^*$ and $V^*$ from $\pi^*$.</p><pre><code>def policy_iteration(P, R, gamma):
  &quot;&quot;&quot;Find V* using policy iteration.

  Args:
    P: numpy array defining transition dynamics. Shape: |S| x |A| x |S|.
    R: numpy array defining rewards. Shape: |S| x |A|.
    gamma: float, discount factor.

  Returns:
    V*: numpy array of shape ns.
    Q*: numpy array of shape ns x na.
  &quot;&quot;&quot;
  assert P.shape[0] == P.shape[2]
  assert P.shape[0] == R.shape[0]
  assert P.shape[1] == R.shape[1]
  ns = P.shape[0]
  na = P.shape[1]
  V = onp.zeros(ns)
  Q = onp.zeros((ns, na))
  pi = onp.zeros((ns, na))
  for s in range(ns):
    pi[s, onp.random.choice(na)] = 1.
  policy_stable = False
  while not policy_stable:
    old_pi = onp.copy(pi)
    # Extract V from Q using pi.
    V = [Q[s, onp.argmax(pi[s])] for s in range(ns)]
    Q = R + gamma * onp.einsum('sat,t-&gt;sa', P, V)
    pi = onp.zeros((ns, na))
    for s in range(ns):
      pi[s, onp.argmax(Q[s])] = 1.
    policy_stable = onp.array_equal(pi, old_pi)
  V = [Q[s, onp.argmax(pi[s])] for s in range(ns)]
  Q = R + gamma * onp.einsum('sat,t-&gt;sa', P, V)
  V = [Q[s, onp.argmax(pi[s])] for s in range(ns)]
  return V, Q
</code></pre><h2 id=learning-the-optimal-value>Learning the optimal value</h2><p>What if one does <em>not</em> have access to $P$ and $R$? This is the most common scenario in reinforcement learning problems, and here the agents must <em>learn</em> how to behave by interacting with the environment.</p><p>The diagram below depicts this pictorially:</p><ul><li>The <em>agent</em>, in state $s$, picks an action $a$ from its policy $\pi(s)$ and sends this action to the environment.</li><li>The <em>environment</em> returns a new state $s'\sim P(s, a)$ and reward $R(s, a)$ to the agent.</li><li>The agent can then use this new information to update its policy $\pi$.</li></ul><h3 id=model-based-versus-model-free-approaches>Model-based versus model-free approaches</h3><p>Two common approaches for handling this are:</p><ol><li><strong>Model-based methods</strong>: Learn approximate models $\hat{P}$ and $\hat{R}$ from the experience received from the environment, and solve for $\hat{V}^*$, $\hat{Q}^*$, and $\hat{\pi}^*$ using value/policy iteration.</li><li><strong>Model-free methods</strong>: Learn approximates $\hat{V}^*$, $\hat{Q}^*$, and/or $\hat{\pi}^*$ using the experience received from the environment.</li></ol><p>There are pros and cons for each of these approaches, and there is extensive (and continuing) research for both.</p><p>For example, model-based methods tend to be more sample-efficient, since one can always sample from $\hat{P}$ and $\hat{R}$ without having to interact with the real environment.</p><p>On the other hand, model-free methods are typically easier to learn and update in an online fashion (as new experience arrives), which is usually desirable.</p><h3 id=value-based-versus-policy-based-approaches>Value-based versus policy-based approaches</h3><p>Within model-free methods, there are two main approaches used: value-based versus policy-based.</p><ul><li><strong>Value-based methods</strong> maintain and update an estimate for $Q^*$</li><li><strong>Policy-based methods</strong> maintain and update an estimate for $\pi^*$</li></ul><p>Once again, there are pros and cons and extensive literature for both of these approaches.</p><p>In this notebook, we will focus on value-based methods.</p><p>You can learn more about policy-based methods in the <a href=http://www.incompleteideas.net/book/the-book-2nd.html>Sutton & Barto book</a> and in the <a href=https://spinningup.openai.com/en/latest/>Spinning up in Deep RL</a> post by <a href=https://openai.com/>Open-AI</a>.</p><h3 id=exploration>Exploration</h3><p>One of the central issues in reinforcement learning is the exploration-exploitation dilemma. This was briefly introduced in the motivating example at the top, but is critical to the eventual performance of the agent.</p><p>Consider an agent that started with an initial policy $\pi_0$, and at iteration $t$ has policy $\pi_t$ and state-action value function $Q^{\pi_t}\gg Q^{\pi_0}$. While at state $s$, the natural thing would be for the agent to pick action $a = \pi_t(s) = \arg\max_{a\in\mathcal{A}}Q^{\pi_t}(s, a)$. This would be a purely <em>exploitative</em> policy.</p><p>What if, had the agent picked a different action, $b\ne a$ that resulted in a very large reward? Imagine the agent <em>had</em> selected action $b$ and the new estimate $Q_{t+1}$ had the property that $Q_{t+1}(s, b) > Q_{t+1}(s, a)$, then the policy would be updated as $\pi_{t+1}(s) = b$.</p><p>At iteration $t$, by definition, $Q^{\pi_t}(s, b) &lt; Q^{\pi_t}(s, a)$, so the agent would have never selected action $b$ with a purely exploitative policy, thereby missing out on a larger reward! Thus, it would have benefited the agent to select <em>sub-optimal</em> action $b$ to uncover the larger reward.</p><p>Selecting a sub-optimal action is what is referred to as <em>exploration</em>, since the reasoning behind choosing sub-optimally is precisely to explore the environment and potentially discover better policies.</p><p>A purely exploratory policy would not be desirable either, as the agent would then always select actions randomly, which would make it unlikely to maximize the expected rewards received.</p><p>As mentioned previously, balancing this exploration-exploitation tradeoff is a very active area of research.</p><h4 id=epsilon-greedy-exploration>$\epsilon$-greedy exploration</h4><p>Perhaps the simplest and best-known exploration method is $\epsilon$-greedy exploration. At state $s$, given a policy $\pi$, the rule for this exploration policy is simply:</p><ul><li>With probability $\epsilon$ select an action randomly</li><li>With probability $1-\epsilon$ select action $a=\arg\max_{a\in\mathcal{A}}\pi(s)$</li></ul><p>The code snippet below implements this exploratory policy.</p><pre><code>def epsilon_greedy(s, pi, epsilon):
  &quot;&quot;&quot;A simple implementation of epsilon-greedy exploration.

  Args:
    s: int, the agent's current state.
    pi: numpy array of shape [num_states, num_actions] encoding the agent's
      policy.
    epsilon: float, the epsilon value for epsilon-greedy exploration.

  Returns:
    An integer representing the action choice.
  &quot;&quot;&quot;
  na = pi.shape[1]
  p = onp.random.rand()
  if onp.random.rand() &lt; epsilon:
    return onp.random.choice(na)
  return onp.random.choice(na, p=pi[s])
</code></pre><h3 id=monte-carlo-methods>Monte Carlo methods</h3><p>Perhaps the simplest way of estimating the sum of future returns is using Monte Carlo methods. These methods execute full <em>trajectories</em> in the environment and estimate $V^{\pi}$ by averaging the observed trajectory returns.</p><p>The algorithm can be described as follows:</p><ol><li>Initialize $Q$ and pick a start state $s$.</li><li>Initialize a list $Returns$ of $|\mathcal{S}|\times|\mathcal{A}|$ elements which accumulates observed returns for each state.</li><li>Initialize $\pi$ randomly.</li><li>While learning:<ol><li>Generate a trajectory $\langle s_0,a_0,r_0,\cdots,s_T,a_T,r_T\rangle$ using $\pi$.</li><li>$G = 0$</li><li>For $t=T$ down to $0$:<ol><li>$G = \gamma G + r_t$</li><li>If $(s_t,a_t)$ does <em>not</em> appear in $\langle s_0,a_0,\cdots,s_{t-1},a_{t-1}\rangle$:<ul><li>Append $G$ to $Returns(s_t, a_t)$</li><li>$Q(s_t, a_t) = average(Returns(s_t, a_t))$</li><li>$\pi(s_t) = \arg\max_{a\in\mathcal{A}} Q(s_t, a)$</li></ul></li></ol></li></ol></li></ol><p>The next code cell implements this approach.</p><pre><code>def monte_carlo(ns, na, step_fn, gamma, start_state, reset_state, total_episodes,
               max_steps_per_iteration, epsilon, V):
  &quot;&quot;&quot;A simple implementation of Q-learning.

  Args:
    ns: int, the number of states.
    na: int, the number of actions.
    step_fn: a function that receives a state and action, and returns a float
      (reward) and next state. This represents the interaction with the
      environment.
    gamma: float, the discount factor.
    start_state: int, index of starting state.
    reset_state: int, index of state where environment resets back to start
      state, or None if there is no reset state.
    total_episodes: int, total number of episodes.
    max_steps_per_iteration: int, maximum number of steps per iteration.
    epsilon: float, exploration rate for epsilon-greedy exploration.
    V: numpy array, true V* used for computing errors. Shape: [num_states].
  
  Returns:
    V_hat: numpy array, learned value function. Shape: [num_states].
    Q_hat: numpy array, learned Q function. Shape: [num_states, num_actions].
    max_errors: list of floats, contains the error max_s |V*(s) - \hat{V}*(s)|.
    avg_errors: list of floats, contains the error avg_s |V*(s) - \hat{V}*(s)|.
  &quot;&quot;&quot;
  # Initialize policy randomly.
  pi_hat = onp.zeros((ns, na))
  for s in range(ns):
    pi_hat[s, onp.random.choice(na)] = 1.
  # Initialize Q randomly.
  Q_hat = onp.zeros((ns, na))
  # Initialize the accumulated returns and number of updates.
  returns = onp.zeros((ns, na))
  counts = onp.zeros((ns, na))
  # Lists to keep track of training statistics.
  iteration_returns = []
  max_errors = []
  avg_errors = []
  for episode in range(total_episodes):
    # Each episode starts in the same start state.
    s = start_state
    step = 0
    # Lists collected for each trajectory.
    states = []
    actions = []
    rewards = []
    # Generate a trajectory for a limited number of steps.
    while step &lt; max_steps_per_iteration:
      step += 1
      states.append(s)
      a = epsilon_greedy(s, pi_hat, epsilon)  # Pick action.
      actions.append(a)
      r, s2 = step_fn(s, a)  # Take a step in the environment.
      rewards.append(r)
      if s2 == reset_state:
        # If we've reached a reset state, the trajectory is over.
        break
      s = s2
    # Update the Q-values based on the rewards received by traversing the
    # trajectory in reverse order.
    G = 0  # Accumulated returns.
    step -= 1
    while step &gt;= 0:
      G = gamma * G + rewards[-1]
      rewards = rewards[:-1]
      s = states[-1]
      states = states[:-1]
      a = actions[-1]
      actions = actions[:-1]
      # We only update Q(s, a) for the first occurence of the pair in the
      # trajectory.
      update_q = True
      for i in range(len(states)):
        if s == states[i] and a == actions[i]:
          update_q = False
          break
      if update_q:
        returns[s, a] += G
        counts[s, a] += 1
        Q_hat[s, a] = returns[s, a] / counts[s, a]
        pi_hat[s] = onp.zeros(na)
        pi_hat[s, onp.argmax(Q_hat[s])] = 1.
      step -= 1
    iteration_returns.append(G)
    V_hat = onp.max(Q_hat, axis=1)
    max_errors.append(onp.max(onp.abs(V - V_hat)))
    avg_errors.append(onp.mean(onp.abs(V - V_hat)))
  return V_hat, Q_hat, iteration_returns, max_errors, avg_errors
</code></pre><h3 id=q-learning>Q-learning</h3><p>Although Monte Carlo methods can update value estimates based on interactions with the environment, a more common approach in reinforcement learning is to use <em>Temporal-Difference</em> (TD) methods. This approach combines ideas from Monte Carlo estimation and dynamic programming.</p><p>Like Monte Carlo methods, Q-learning updates its estimates from sampled experiences; but like dynamic programming methods, it does so with <em>single-step</em> transitions. In its simplest form, after performing action $a$ from state $s$ and observing reward $r$ and next state$s'$, Q-learning updates its estimate of $V^{\pi}(s)$ as follows:</p><p>$Q^{\pi}(s, a) = V^{\pi}(s) + \alpha\left[ r + \gamma V^{\pi}(s') - V^{\pi}(s)\right]$</p><p>Here, $\alpha\in[0, 1]$ is the <em>step size</em>, and determines how aggressively we will update our estimates given new evidence from the environment.</p><p>In this simplified setting we are assuming $\alpha$ remains fixed once selected, but there are more sophisticated methods which varies it throughout training. The algorithm proceeds as follows:</p><ol><li>Initialize $Q$ and $\pi$, and pick a start state $s$.</li><li>While learning:</li><li>Pick action $a$ according to $\pi$ (and any exploratory policy).</li><li>Send $a$ to the environment and receive $s'$ and $r$ in return.</li><li>Compute the TD-error as:<br>$\delta = r + \gamma \max_{a'\in\mathcal{A}}Q(s', a') - Q(s, a)$</li><li>Update the estimate for $Q(s, a)$ as follows:<br>$Q(s, a) = Q(s, a) + \alpha\delta$</li><li>$\pi(s) = \arg\max_{a\in\mathcal{A}} Q(s, a)$</li><li>Update $s = s'$.</li></ol><p>The next cell provides an implementation of Q-learning.</p><pre><code>def q_learning(ns, na, step_fn, gamma, start_state, reset_state, total_episodes,
               max_steps_per_iteration, epsilon, alpha, V):
  &quot;&quot;&quot;A simple implementation of Q-learning.

  Args:
    ns: int, the number of states.
    na: int, the number of actions.
    step_fn: a function that receives a state and action, and returns a float
      (reward) and next state. This represents the interaction with the
      environment.
    gamma: float, the discount factor.
    start_state: int, index of starting state.
    reset_state: int, index of state where environment resets back to start
      state, or None if there is no reset state.
    total_episodes: int, total number of episodes.
    max_steps_per_iteration: int, maximum number of steps per iteration.
    epsilon: float, exploration rate.
    alpha: float, learning rate.
    V: numpy array, true V* used for computing errors. Shape: [num_states].
  
  Returns:
    V_hat: numpy array, learned value function. Shape: [num_states].
    Q_hat: numpy array, learned Q function. Shape: [num_states, num_actions].
    max_errors: list of floats, contains the error max_s |V*(s) - \hat{V}*(s)|.
    avg_errors: list of floats, contains the error avg_s |V*(s) - \hat{V}*(s)|.
  &quot;&quot;&quot;
  # Initialize policy randomly.
  pi_hat = onp.zeros((ns, na))
  for s in range(ns):
    pi_hat[s, onp.random.choice(na)] = 1.
  # Initialize Q to zeros.
  Q_hat = onp.zeros((ns, na))
  # Lists collected for each trajectory.
  iteration_returns = []
  max_errors = []
  avg_errors = []
  for episode in range(total_episodes):
    # Each episode begins in the same start state.
    s = start_state
    step = 0
    num_episodes = 0
    steps_in_episode = 0
    cumulative_return = 0.
    average_episode_returns = 0.
    # Interact with the environment for a maximum number of steps
    while step &lt; max_steps_per_iteration:
      a = epsilon_greedy(s, pi_hat, epsilon)  # Pick action.
      r, s2 = step_fn(s, a)  # Take a step in the environment.
      delta = r + gamma * max(Q_hat[s2]) - Q_hat[s, a]  # TD-error.
      Q_hat[s, a] += alpha * delta  # Q-learning update.
      cumulative_return += gamma**(steps_in_episode) * r
      pi_hat[s] = onp.zeros(na)
      pi_hat[s, onp.argmax(Q_hat[s])] = 1.
      s = s2
      steps_in_episode += 1
      if s2 == reset_state:
        s = 0
        num_episodes += 1
        steps_in_episode = 0
        average_episode_returns += cumulative_return
        cumulative_return = 0.
      step += 1
    average_episode_returns /= max(1, num_episodes)
    iteration_returns.append(average_episode_returns)
    V_hat = onp.max(Q_hat, axis=1)
    max_errors.append(onp.max(onp.abs(V - V_hat)))
    avg_errors.append(onp.mean(onp.abs(V - V_hat)))
  return V_hat, Q_hat, iteration_returns, max_errors, avg_errors
</code></pre><h2 id=colab>Colab!</h2><p>The rest of this intro is hands-on, so you should follow the instructions in <a href="https://colab.research.google.com/github/psc-g/intro_to_rl/blob/master/Introduction_to_reinforcement_learning.ipynb#scrollTo=XVrlWe2YPpXt">the colab</a>.</p></div><div class=btn-improve-page><a href=https://github.com/psc-g/psc-g.github.io/edit/master/content/posts/mentoring/intro-to-rl.md><i class="fas fa-code-branch"></i>Improve this page</a></div><hr><div class="row next-prev-navigator"><div class="col-md-6 previous-article"><a href=/posts/research/creativity/ganterpretations/ class="btn btn-outline-info"><span><i class="fas fa-chevron-circle-left"></i>Prev</span><br><span>GANterpretations</span></a></div><div class="col-md-6 next-article"><a href=/posts/research/other/rigl/rigl/ class="btn btn-outline-info"><span>Next <i class="fas fa-chevron-circle-right"></i></span><br><span>Rigging the Lottery: Making All Tickets Winners</span></a></div></div><hr><div id=disqus_thread></div><script type=text/javascript>(function(){if(window.location.hostname=="localhost")return;var dsq=document.createElement("script");dsq.type="text/javascript";dsq.async=true;var disqus_shortname="does-not-exist";dsq.src="//"+disqus_shortname+".disqus.com/embed.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(dsq);})();</script><noscript>Please enable JavaScript to view the
<a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com/ class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></div></div></section><section class=toc-section id=toc-section><div class=toc-holder><h5 class="text-center pl-3">Table of Contents</h5><hr><div class=toc><nav id=TableOfContents><ul><li><a href=#introduction>Introduction</a></li><li><a href=#a-motivating-example>A motivating example</a></li><li><a href=#markov-decision-processes>Markov decision processes</a><ul><li><a href=#policies-and-value-functions>Policies and value functions</a></li><li><a href=#optimal-policies-and-value-functions>Optimal policies and value functions</a></li></ul></li><li><a href=#computing-the-optimal-value-exactly>Computing the optimal value exactly</a><ul><li><a href=#value-iteration>Value iteration</a></li><li><a href=#policy-iteration>Policy iteration</a></li></ul></li><li><a href=#learning-the-optimal-value>Learning the optimal value</a><ul><li><a href=#model-based-versus-model-free-approaches>Model-based versus model-free approaches</a></li><li><a href=#value-based-versus-policy-based-approaches>Value-based versus policy-based approaches</a></li><li><a href=#exploration>Exploration</a><ul><li><a href=#epsilon-greedy-exploration>$\epsilon$-greedy exploration</a></li></ul></li><li><a href=#monte-carlo-methods>Monte Carlo methods</a></li><li><a href=#q-learning>Q-learning</a></li></ul></li><li><a href=#colab>Colab!</a></li></ul></nav></div></div></section></div><footer class="container-fluid text-center align-content-center footer pb-2"><div class="container pt-5"><div class="row text-left"><div class="col-md-4 col-sm-12"><h5>Navigation</h5><ul><li class=nav-item><a class=smooth-scroll href=#about>About</a></li><li class=nav-item><a class=smooth-scroll href=#recent-posts>Recent Posts</a></li><li class=nav-item><a class=smooth-scroll href=#publications>Publications</a></li></ul></div><div class="col-md-4 col-sm-12"><h5>Contact me:</h5><ul><li><span><a href=https://twitter.com/@pcastr target=_blank>Twitter <i class="fab fa-twitter"></i></a></span></li></ul></div></div></div><hr><div class=container><div class="row text-left"><div class=col-md-4><a id=theme href=https://github.com/hossainemruz/toha target=#><img src=/assets/images/inverted-logo.png>
Toha</a></div><div class="col-md-4 text-center">© 2020 Copyright.</div><div class="col-md-4 text-right"><a id=hugo href=https://gohugo.io/>Powered by
<img src=/assets/images/hugo-logo-wide.svg alt="Hugo Logo" height=18></a></div></div></div></footer><script src=/assets/js/jquery-3.4.1.min.js></script><script src=/assets/js/popper.min.js></script><script src=/assets/js/bootstrap.min.js></script><script src=/assets/js/navbar.js></script><script src=/assets/js/main.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js></script><script src=/assets/js/single.js></script><script>hljs.initHighlightingOnLoad();</script></body></html>